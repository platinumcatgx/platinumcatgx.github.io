<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Docker | 逍 - BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="docker安装 运行与停止 运行 docker run ubuntu:15.10 &#x2F;bin&#x2F;echo “Hello world”  docker: Docker 的二进制执行文件。 run: 与前面的 docker 组合来运行一个容器 ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="http://example.com/2021/06/21/Docker-docker/index.html">
<meta property="og:site_name" content="逍 - BLOG">
<meta property="og:description" content="docker安装 运行与停止 运行 docker run ubuntu:15.10 &#x2F;bin&#x2F;echo “Hello world”  docker: Docker 的二进制执行文件。 run: 与前面的 docker 组合来运行一个容器 ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-06-21T01:03:33.120Z">
<meta property="article:modified_time" content="2021-06-21T01:03:33.120Z">
<meta property="article:author" content="bloodthirsty - platinumcatgx">
<meta property="article:tag" content="旧笔记 | Docker">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="逍 - BLOG" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">逍 - BLOG</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Docker-docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/21/Docker-docker/" class="article-date">
  <time datetime="2021-06-21T01:03:33.120Z" itemprop="datePublished">2021-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Docker
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr>
<h2 id="运行与停止"><a href="#运行与停止" class="headerlink" title="运行与停止"></a>运行与停止</h2><hr>
<p><strong>运行</strong></p>
<p><code>docker run</code> ubuntu:15.10 /bin/echo “Hello world”</p>
<ul>
<li>docker: Docker 的二进制执行文件。</li>
<li>run: 与前面的 docker 组合来运行一个容器</li>
<li>ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li>/bin/echo “Hello world”: 在启动的容器里执行的命令</li>
</ul>
<p><strong>运行交互式容器</strong></p>
<p>docker run -i -t ubuntu:15.10 /bin/bash</p>
<ul>
<li><code>-t</code>: 在新容器内指定一个伪终端或终端。</li>
<li><code>-i</code>: 允许你对容器内的标准输入 (STDIN) 进行交互。</li>
<li><code>-d</code>: 在后台运行</li>
<li><code>-P</code>: 将容器内部使用的网络端口随机映射到我们使用的主机上</li>
</ul>
<p><strong>运行(后台模式)</strong></p>
<p>docker run -d ubuntu:15.10 /bin/sh -c “while true; do echo hello world; sleep 1; done”</p>
<p>运行只有一长串字符, 这个字符叫<code>容器ID</code>,</p>
<p>通过<code>docker ps</code> 查看容器信息</p>
<blockquote>
<p>输出详情介绍：</p>
<p><strong>CONTAINER ID</strong>: 容器 ID。</p>
<p><strong>IMAGE</strong>: 使用的镜像。</p>
<p><strong>COMMAND</strong>: 启动容器时运行的命令。</p>
<p><strong>CREATED</strong>: 容器的创建时间。</p>
<p><strong>STATUS</strong>: 容器状态。</p>
<p><strong>状态</strong>有 7 种：</p>
<blockquote>
<p>created（已创建）</p>
<p>restarting（重启中）</p>
<p>running 或 Up（运行中）</p>
<p>removing（迁移中）</p>
<p>paused（暂停）</p>
<p>exited（停止）</p>
<p>dead（死亡）</p>
</blockquote>
<p><strong>PORTS</strong>: 容器的端口信息和使用的连接类型（tcp\udp）。</p>
<p><strong>NAMES</strong>: 自动分配的容器名称。输出详情介绍：</p>
</blockquote>
<p><strong>停止容器</strong></p>
<p><code>docker stop [容器ID/容器名称]</code></p>
<hr>
<h2 id="容器的使用"><a href="#容器的使用" class="headerlink" title="容器的使用"></a>容器的使用</h2><p><strong>docker 客户端</strong></p>
<p><strong>容器使用</strong></p>
<p>获取镜像</p>
<p><code>docker pull ubuntu</code></p>
<p>启动已停止运行的容器</p>
<p>查看所有容器<br><code>docker ps -a</code>;<br><code>docker start dc0819ab449f</code></p>
<p>进入后台启动的容器</p>
<p><code> docker attach</code> : 如果从这个容器退出，会导致容器的停止。</p>
<p><code>docker exec</code>: docker exec 命令退出容器终端，不会导致容器的停止</p>
<h3 id="容器的导入和导出"><a href="#容器的导入和导出" class="headerlink" title="容器的导入和导出"></a>容器的导入和导出</h3><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p><code>docker export DOCKER_NAME &gt; FILENAME.tar</code> 导出容器 DOCKER_NAME 快照到本地文件 ubuntu.tar</p>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p><code>cat docker/ubuntu.tar | docker import - test/ubuntu:v1</code> 将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</p>
<p><code>docker import http://example.com/exampleimage.tgz example/imagerepo</code> 通过指定 URL 或者某个目录来导入</p>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p><code>docker rm -f DOCKER_NAME</code></p>
<p>###运行一个 web 应用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~# docker pull training/webapp  # 载入镜像</span><br><span class="line">runoob@runoob:~# docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>

<p>docker ps -a 可以看到, 多了端口信息<br><code>0.0.0.0:32769-&gt;5000/tcp</code> : Docker 开放了端口 5000, 并映射到了本机的 32769 端口</p>
<p>通过 -P 设置端口<br><code>docker run -d -p 5000:5000 training/webapp python app.py</code></p>
<h3 id="快速查看-docker-端口"><a href="#快速查看-docker-端口" class="headerlink" title="快速查看 docker 端口"></a>快速查看 docker 端口</h3><p><code>docker port NAME</code></p>
<h3 id="查看-web-应用的日志"><a href="#查看-web-应用的日志" class="headerlink" title="查看 web 应用的日志"></a>查看 web 应用的日志</h3><p><code>docker logs [ID或者名字]</code> 可以查看容器内部的标准输出。</p>
<h3 id="查看-web-应用的进程"><a href="#查看-web-应用的进程" class="headerlink" title="查看 web 应用的进程"></a>查看 web 应用的进程</h3><p><code>docker top [ID或者名字]</code> 查看内部运行的程序</p>
<h3 id="检查-WEB-应用程序"><a href="#检查-WEB-应用程序" class="headerlink" title="检查 WEB 应用程序"></a>检查 WEB 应用程序</h3><p>使用 <code>docker inspect</code> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p>
<h3 id="停止-WEB-应用容器"><a href="#停止-WEB-应用容器" class="headerlink" title="停止 WEB 应用容器"></a>停止 WEB 应用容器</h3><p><code>docker stop NAME</code></p>
<h3 id="重启-WEB-应用容器"><a href="#重启-WEB-应用容器" class="headerlink" title="重启 WEB 应用容器"></a>重启 WEB 应用容器</h3><p>已经停止的容器，我们可以使用命令 <code>docker start</code> 来启动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start wizardly_chandrasekhar</span><br><span class="line">wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>

<p><code>docker ps -l</code> 查询最后一次创建的容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                             PORTS                     NAMES</span><br><span class="line">bf08b7f2cd89        training/webapp     ...        0.0.0.0:5000-&gt;5000/tcp    wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>

<p>正在运行的容器，我们可以使用 docker restart 命令来重启。</p>
<h3 id="移除-WEB-应用容器"><a href="#移除-WEB-应用容器" class="headerlink" title="移除 WEB 应用容器"></a>移除 WEB 应用容器</h3><p>我们可以使用 docker rm 命令来删除不需要的容器</p>
<p><code>docker rm wizardly_chandrasekhar </code><br>删除容器时，容器必须是停止状态，否则会报如下错</p>
<hr>
<h2 id="docker-镜像使用"><a href="#docker-镜像使用" class="headerlink" title="docker 镜像使用"></a>docker 镜像使用</h2><ol>
<li>管理镜像</li>
<li>创建镜像</li>
</ol>
<p>列出本地镜像<br><code>docker images</code></p>
<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像 ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
<p>预先下载镜像<br><code>docker pull dockerIDNAME</code></p>
<p>查找镜像<br>在 docker hub 上找 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a><br><code>docker search name</code></p>
<ul>
<li>NAME: 镜像仓库源的名称</li>
<li>DESCRIPTION: 镜像的描述</li>
<li>OFFICIAL: 是否 docker 官方发布</li>
<li>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>
<li>AUTOMATED: 自动构建。</li>
</ul>
<p>huo 取镜像<br>docker pull name</p>
<p>删除镜像<br>docker rm name</p>
<h4 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h4><ol>
<li>从已经创建的容器中更新镜像，并且提交这个镜像</li>
<li>使用 Dockerfile 指令来创建一个新的镜像</li>
</ol>
<ul>
<li><code> docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</code></li>
<li>参数说明<ul>
<li>-m: 提交的描述信息</li>
<li>-a: 指定镜像作者</li>
<li>e218edb10161：容器 ID</li>
<li>runoob/ubuntu:v2: 指定要创建的目标镜像名</li>
</ul>
</li>
</ul>
<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p><code>docker build</code> ， 从零开始来创建一个新的镜像</p>
<p>为此，我们需要创建一个 Dockerfile(这里不描述了) 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ cat Dockerfile</span><br><span class="line">FROM    centos:6.7</span><br><span class="line">MAINTAINER      Fisher &quot;fisher@sudops.com&quot;</span><br><span class="line"></span><br><span class="line">RUN     /bin/echo &#x27;root:123456&#x27; |chpasswd</span><br><span class="line">RUN     useradd runoob</span><br><span class="line">RUN     /bin/echo &#x27;runoob:123456&#x27; |chpasswd</span><br><span class="line">RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/local</span><br><span class="line">EXPOSE  22</span><br><span class="line">EXPOSE  80</span><br><span class="line">CMD     /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure>

<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p>
<p>第一条 FROM，指定使用哪个镜像源</p>
<p>RUN 指令告诉 docker 在镜像内执行命令，安装了什么。。。</p>
<p>然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</p>
<p><code>docker build -t runoob/centos:6.7 .</code></p>
<ul>
<li><code>-t</code> ：指定要创建的目标镜像名</li>
<li><code>.</code> ：Dockerfile 文件所在目录，可以指定 Dockerfile 的绝对路径</li>
</ul>
<h4 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h4><p>使用<code>docker tag</code>命令<br><code>docker tag 860c279d2fec runoob/centos:dev</code><br>docker tag 镜像 ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)</p>
<h2 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h2><blockquote>
<p>前面我们实现了通过网络端口来访问运行在 docker 容器内的服务。<br>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。<br>下面我们来实现通过端口连接到一个 docker 容器。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>

<p>还可以用-p 绑定网络地址(例如 127.0.0.1)</p>
<ul>
<li><strong>-P</strong> :是容器内部端口<strong>随机</strong>映射到主机的高端口。</li>
<li><strong>-p</strong> : 是容器内部端口<strong>绑定</strong>到指定的主机端口。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>

<p>默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。</p>
<p>docker port 命令可以让我们快捷地查看端口的绑定情况。</p>
<h3 id="Docker-容器互联"><a href="#Docker-容器互联" class="headerlink" title="Docker 容器互联"></a>Docker 容器互联</h3><p>docker 有一个连接系统, 可以将多个系统连接到一起, 共享连接信息</p>
<p>docker 连接会创建一个父子关系，其中<br>父容器可以看到子容器的信息</p>
<h4 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h4><p><code>docker run -d -P --name runoob training/webapp python app.py</code></p>
<p>docker rename oldName newName<br>重命名已有容器</p>
<h3 id="新建-Docker-网络"><a href="#新建-Docker-网络" class="headerlink" title="新建 Docker 网络"></a>新建 Docker 网络</h3><p><code>docker network create -d bridge test-net</code></p>
<p>-d：参数指定 Docker 网络类型，有 bridge、overlay。<br>overlay 网络类型用于 Swarm mode</p>
<h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的网络<br>创建见两个容器, 并加入网络 test-net</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name test1 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name test2 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>在容器中使用 ping [另一个容器的 name]</p>
<h3 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h3><ol>
<li>在宿主机的/etc/docker/daemon.json 文件中加入一下内容来设置全部容器的 DNS</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;114.114.114.114&quot;,</span><br><span class="line">    &quot;8.8.8.8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。</p>
<p>配置完，需要重启 docker 才能生效。</p>
<p>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：<br><code>docker run -it --rm ubuntu cat etc/resolv.conf</code> 2. 手动指定容器的配置<br>在指定的容器设置 DNS<br><code>docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu</code></p>
<ul>
<li>参数说明：<ul>
<li><code>--rm</code>：容器退出时自动清理容器内部的文件系统。</li>
<li><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code>： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</li>
<li><code>--dns=IP_ADDRESS</code>： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</li>
<li><code>--dns-search=DOMAIN</code>： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</li>
</ul>
</li>
</ul>
<p>如果在容器启动时没有指定 –dns 和 –dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS</p>
<hr>
<p>解决 windows 系统无法对 docker 容器进行端口映射的问题<br>1、问题：</p>
<p>在 Windows 家庭版下安装了 docker，并尝试在其中运行 jupyter notebook 等服务，但映射完毕之后，在主机的浏览器中，打开 localhost:port 无法访问对应的服务。</p>
<p>2、问题出现的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The reason you’re having this, is because on Linux, the docker daemon (and your containers) run on the Linux machine itself, so “localhost” is also the host that the container is running on, and the ports are mapped to.</span><br><span class="line"></span><br><span class="line">On Windows (and OS X), the docker daemon, and your containers cannot run natively, so only the docker client is running on your Windows machine, but the daemon (and your containers) run in a VirtualBox Virtual Machine, that runs Linux.</span><br></pre></td></tr></table></figure>

<p>因为 docker 是运行在 Linux 上的，在 Windows 中运行 docker，实际上还是在 Windows 下先安装了一个 Linux 环境，然后在这个系统中运行的 docker。也就是说，服务中使用的 localhost 指的是这个 Linux 环境的地址，而不是我们的宿主环境 Windows。</p>
<p>3、解决方法：</p>
<p>通过命令:</p>
<p>docker-machine ip default # 其中，default 是 docker-machine 的 name，可以通过 docker-machine -ls 查看<br>找到这个 Linux 的 ip 地址，一般情况下这个地址是 192.168.99.100，然后在 Windows 的浏览器中，输入这个地址，加上服务的端口即可启用了。</p>
<p>比如，首先运行一个 docker 容器：</p>
<p>docker run -it -p 8888:8888 conda:v1<br>其中，conda:v1 是我的容器名称。然后在容器中开启 jupyter notebook 服务：</p>
<p>jupyter notebook –no-browser –port=8888 –ip=172.17.0.2 –allow-root<br>其中的 ip 参数为我的容器的 ip 地址，可以通过如下命令获得：</p>
<p>docker inspect container_id<br>最后在 windows 浏览器中测试结果：</p>
<h2 id="http-192-168-99-100-8888"><a href="#http-192-168-99-100-8888" class="headerlink" title="http://192.168.99.100:8888"></a><a target="_blank" rel="noopener" href="http://192.168.99.100:8888/">http://192.168.99.100:8888</a></h2><hr>
<h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><p>Docker Hub, docker 官方维护的一个公共仓库</p>
<p>注册<br>在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<p>登录和退出<br>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logout</span><br></pre></td></tr></table></figure>

<p>搜索镜像<br><code>docker search ubuntu</code><br>拉取镜像<br><code>docker pull ubuntu</code><br>推送镜像<br><code>docker push</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker tag ubuntu:18.04 Docker账号用户名/ubuntu:18.04</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG        IMAGE ID            CREATED           ...</span><br><span class="line">ubuntu          18.04      275d79972a86        6 days ago        ...</span><br><span class="line">username/ubuntu 18.04      275d79972a86        6 days ago        ...</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker push username/ubuntu:18.04</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker search username/ubuntu</span></span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATED</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明</p>
<p>指令介绍</p>
<ul>
<li><p>FROM</p>
<ul>
<li>定制的镜像都是基于 FROM 的镜像</li>
</ul>
</li>
<li><p>RUN</p>
<ul>
<li>用于执行后面跟着的命令行命令</li>
</ul>
</li>
</ul>
<p>shell 格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></span><br></pre></td></tr></table></figure>

<p>exec 格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数 1&quot;, &quot;参数 2&quot;]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN [<span class="string">&quot;./test.php&quot;</span>, <span class="string">&quot;dev&quot;</span>, <span class="string">&quot;offline&quot;</span>] 等价于 RUN ./test.php dev offline</span></span><br></pre></td></tr></table></figure>

<p>Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大, 以 &amp;&amp; 符号连接命令，这样执行后，可以减少镜像层数</p>
<h3 id="构建镜像-1"><a href="#构建镜像-1" class="headerlink" title="构建镜像"></a>构建镜像</h3><p><code>docker build -t NAME:TAG .</code><br>这里的<code>.</code> 是上下文路径</p>
<blockquote>
<p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p>
<p>解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p>
<p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p>
<p>注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p>
</blockquote>
<p>指令介绍</p>
<p>COPY</p>
<p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure>

<p><code>[--chown=&lt;user&gt;:&lt;group&gt;]</code>：可选参数，用户改变复制到容器内文件的拥有者和属组。<br><code>&lt;源路径&gt;</code>：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则<br><code>&lt;目标路径&gt;</code>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建</p>
<p><strong>ADD</strong><br>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p>
<ul>
<li><p>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</p>
</li>
<li><p>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。<br><strong>CMD</strong><br>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>
</li>
<li><p>CMD 在 docker run 时运行。</p>
</li>
<li><p>RUN 是在 docker build。<br>_作用_：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p>
</li>
</ul>
<p>_注意_：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p>
<p>格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt;</span><br><span class="line">CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]# 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span><br></pre></td></tr></table></figure>

<p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p>
<p><strong>ENTRYPOINT</strong><br>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>
<p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p>
<p>优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure>

<p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p>
<p>示例：</p>
<p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;nginx&quot;,&quot;-c&quot;]# 定参</span><br><span class="line">CMD [&quot;/etc/nginx/nginx.conf&quot;]# 变参</span><br></pre></td></tr></table></figure>

<p>1、不传参运行</p>
<p>$ docker run nginx:test<br>容器内会默认运行以下命令，启动主进程。</p>
<p>nginx -c /etc/nginx/nginx.conf<br>2、传参运行</p>
<p>$ docker run nginx:test -c /etc/nginx/new.conf<br>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>
<p>nginx -c /etc/nginx/new.conf<br><strong>ENV</strong><br>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<p>格式：</p>
<p>ENV <key><value><br>ENV <key1>=<value1><key2>=<value2>…<br>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \</span><br><span class="line"> &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>ARG</strong><br>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p>
<p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p>
<p>格式：</p>
<p>ARG &lt;参数名&gt;[=&lt;默认值&gt;]<br><strong>VOLUME</strong><br>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<p>作用：</p>
<p>避免重要的数据，因容器重启而丢失，这是非常致命的。<br>避免容器不断变大。<br>格式：</p>
<p>VOLUME [“&lt;路径 1&gt;”,”&lt;路径 2&gt;”…]<br>VOLUME &lt;路径&gt;<br>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p>
<p><strong>EXPOSE</strong><br>仅仅只是声明端口。</p>
<p>作用：</p>
<p>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。<br>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。<br>格式：</p>
<p>EXPOSE &lt;端口 1&gt;[&lt;端口 2&gt;…]<br><strong>WORKDIR</strong><br>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p>
<p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>
<p>格式：</p>
<p>WORKDIR &lt;工作目录路径&gt;<br><strong>USER</strong><br>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<p>格式：</p>
<p>USER &lt;用户名&gt;[:&lt;用户组&gt;]<br><strong>HEALTHCHECK</strong><br>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p>
<p>格式：</p>
<p>HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令<br>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</p>
<p>HEALTHCHECK [选项] CMD &lt;命令&gt;:这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。<br><strong>ONBUILD</strong><br>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p>
<p>格式：</p>
<p>ONBUILD &lt;其它指令&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/21/Docker-docker/" data-id="ckqbssevj0000rw1zf0ro930g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A7%E7%AC%94%E8%AE%B0-Docker/" rel="tag">旧笔记 | Docker</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/06/23/%E6%A1%86%E6%9E%B62/RocketMQ/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/06/21/oracle/%E8%A7%A6%E5%8F%91%E5%99%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">触发器</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Dubbo/">Dubbo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Boot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">Spring Boot | 配置文件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A7%E7%AC%94%E8%AE%B0/" rel="tag">旧笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A7%E7%AC%94%E8%AE%B0-Docker/" rel="tag">旧笔记 | Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A7%E7%AC%94%E8%AE%B0-oracle/" rel="tag">旧笔记 | oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" rel="tag">配置文件</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a> <a href="/tags/zookeeper/" style="font-size: 10px;">zookeeper</a> <a href="/tags/%E6%97%A7%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">旧笔记</a> <a href="/tags/%E6%97%A7%E7%AC%94%E8%AE%B0-Docker/" style="font-size: 10px;">旧笔记 | Docker</a> <a href="/tags/%E6%97%A7%E7%AC%94%E8%AE%B0-oracle/" style="font-size: 20px;">旧笔记 | oracle</a> <a href="/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" style="font-size: 10px;">配置文件</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/24/spring/SpringBoot%E6%95%B4%E5%90%88RocketMQ/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/23/%E6%A1%86%E6%9E%B62/RocketMQ/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/21/Docker-docker/">Docker</a>
          </li>
        
          <li>
            <a href="/2021/06/21/oracle/%E8%A7%A6%E5%8F%91%E5%99%A8/">触发器</a>
          </li>
        
          <li>
            <a href="/2021/06/21/oracle/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%98%E5%87%BD%E6%95%B0/">存储过程与存函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 bloodthirsty - platinumcatgx<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>