/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping,
// which, as a code snippet, is in the public domain, per 
// https://developer.mozilla.org/en-US/docs/MDN/About#copyrights_and_licenses
// (as of 2021-07-15):
function escapeRegExp(string) {
    // $& means the whole matched string:
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
const toggleQuote = (linesInput, prefix) => __awaiter(void 0, void 0, void 0, function* () {
    const fullLines = [...linesInput];
    const escapedPrefix = escapeRegExp(prefix);
    const leadingWhitespaces = fullLines.map((e) => {
        const whitespaceMatch = e.match(new RegExp(`^(\\s*)`));
        return whitespaceMatch !== null ? whitespaceMatch[1] : "";
    });
    // This is in its own variable to aid in debugging:
    let filteredLeadingWhitespaces = leadingWhitespaces.filter((e, i) => {
        // Get rid of blank lines, which might be part of multi-line
        // passages:
        return fullLines[i] !== "";
    });
    // Account for if all lines actually *are* unindented, and we thus
    // filtered all lines out immediately above:
    const filteredLeadingLengths = (filteredLeadingWhitespaces.length > 0 ? filteredLeadingWhitespaces : [""]).map((e) => e.length);
    const minLeadingWhitespaceLength = Math.min(...filteredLeadingLengths);
    // Determine whether *every* line is Prefixed or not. If not, we will
    // add the prefix to every line; if so, we will remove it from every line.
    const isEveryLinePrefixed = fullLines.every((e) => {
        const prefixMatch = e.match(new RegExp(`^\\s{${minLeadingWhitespaceLength}}${escapedPrefix}`));
        if (prefixMatch !== null) {
            return true;
        }
        return false;
    });
    // Make an educated guess about using tabs vs spaces (lacking access to the
    // "Use Tabs" setting value in Obsidian for now) by just repurposing the
    // first actual instance of leading whitespace:
    const exampleLeadingWhitespace = leadingWhitespaces.filter((e) => e.length === minLeadingWhitespaceLength);
    // Update the text in-place:
    for (const [i, text] of fullLines.entries()) {
        if (isEveryLinePrefixed === true) {
            if (text === "") {
                fullLines[i] =
                    exampleLeadingWhitespace.length > 0
                        ? exampleLeadingWhitespace[0]
                        : " ".repeat(minLeadingWhitespaceLength);
                continue;
            }
            fullLines[i] = text.replace(new RegExp(`^(\\s{${minLeadingWhitespaceLength}})${escapedPrefix}`), "$1");
            continue;
        }
        if (text === "") {
            fullLines[i] =
                (exampleLeadingWhitespace.length > 0
                    ? exampleLeadingWhitespace[0]
                    : " ".repeat(minLeadingWhitespaceLength)) + prefix;
            continue;
        }
        // If the prefix is already in the correct place, do not add to it:
        if (!text.match(new RegExp(`^\\s{${minLeadingWhitespaceLength}}${escapedPrefix}`))) {
            fullLines[i] = text.replace(new RegExp(`^(\\s{${minLeadingWhitespaceLength}})`), `$1${prefix}`);
        }
    }
    return {
        lines: fullLines,
        minLeadingWhitespaceLength: minLeadingWhitespaceLength,
        isEveryLinePrefixed: isEveryLinePrefixed,
    };
});
const toggleQuoteInEditor = (view, prefix) => __awaiter(void 0, void 0, void 0, function* () {
    const editor = view.editor;
    const currentSelectionStart = editor.getCursor("from");
    const currentSelectionEnd = editor.getCursor("to");
    const replacementRange = [
        { line: currentSelectionStart.line, ch: 0 },
        {
            line: currentSelectionEnd.line,
            ch: editor.getLine(currentSelectionEnd.line).length,
        },
    ];
    const fullSelectedLines = editor
        .getRange(replacementRange[0], replacementRange[1])
        .split("\n");
    const { lines, minLeadingWhitespaceLength, isEveryLinePrefixed } = yield toggleQuote(fullSelectedLines, prefix);
    editor.replaceRange(lines.join("\n"), replacementRange[0], replacementRange[1]);
    let newSelectionStartCh;
    if (currentSelectionStart.ch < minLeadingWhitespaceLength) {
        newSelectionStartCh = currentSelectionStart.ch;
    }
    else {
        if (isEveryLinePrefixed) {
            newSelectionStartCh = currentSelectionStart.ch - prefix.length;
        }
        else {
            newSelectionStartCh = currentSelectionStart.ch + prefix.length;
        }
    }
    let newSelectionEndCh;
    if (currentSelectionEnd.ch < minLeadingWhitespaceLength) {
        newSelectionEndCh = currentSelectionEnd.ch;
    }
    else {
        if (isEveryLinePrefixed) {
            newSelectionEndCh = currentSelectionEnd.ch - prefix.length;
        }
        else {
            newSelectionEndCh = currentSelectionEnd.ch + prefix.length;
        }
    }
    editor.setSelection({
        line: currentSelectionStart.line,
        ch: newSelectionStartCh,
    }, {
        line: currentSelectionEnd.line,
        ch: newSelectionEndCh,
    });
});

var Mode;
(function (Mode) {
    Mode["Text"] = "Text";
    Mode["TextBlockquote"] = "Text (Blockquote)";
    Mode["Markdown"] = "Markdown";
    Mode["MarkdownBlockquote"] = "Markdown (Blockquote)";
    Mode["CodeBlock"] = "Code Block";
    Mode["CodeBlockBlockquote"] = "Code Block (Blockquote)";
    Mode["Passthrough"] = "Passthrough";
})(Mode || (Mode = {}));
class PasteModeModal extends obsidian.FuzzySuggestModal {
    constructor({ app, onChooseItem, currentValue, }) {
        super(app);
        this.setPlaceholder(`Current: ${currentValue}`);
        this.setInstructions([
            {
                command: `Paste Mode`,
                purpose: "",
            },
        ]);
        this.onChooseItem = (patternIndex) => {
            onChooseItem(patternIndex);
            // Note: Using this.close() here was causing a bug whereby new
            // text was unable to be typed until the user had opened another
            // modal or switched away from the window. @lishid noted at
            // https://github.com/obsidianmd/obsidian-releases/pull/396#issuecomment-894017526
            // that the modal is automatically closed at the conclusion of
            // onChooseItem.
        };
    }
    getItems() {
        return Object.keys(Mode).map((key, index) => index);
    }
    getItemText(index) {
        return Object.values(Mode)[index];
    }
}
const DEFAULT_SETTINGS = {
    blockquotePrefix: "> ",
    mode: Mode.Markdown,
    apiVersion: 2,
};
class PastetoIndentationPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadSettings();
            const changePasteMode = (value) => __awaiter(this, void 0, void 0, function* () {
                this.settings.mode = value;
                yield this.saveSettings();
                this.statusBar.setText(`Paste Mode: ${value}`);
            });
            this.addSettingTab(new SettingTab(this.app, this));
            this.app.workspace.on("editor-paste", (evt, editor) => __awaiter(this, void 0, void 0, function* () {
                // Per https://github.com/obsidianmd/obsidian-api/blob/master/obsidian.d.ts#L3690,
                // "Check for `evt.defaultPrevented` before attempting to handle this
                // event, and return if it has been already handled."
                if (evt.defaultPrevented) {
                    return;
                }
                if (evt.clipboardData.types.every((type) => type === "files")) {
                    return;
                }
                let mode = this.settings.mode;
                if (mode === Mode.Passthrough) {
                    return;
                }
                evt.preventDefault();
                let clipboardContents = "";
                let output = "";
                if (mode === Mode.Markdown || mode === Mode.MarkdownBlockquote) {
                    clipboardContents = obsidian.htmlToMarkdown(evt.clipboardData.getData("text/html"));
                    // htmlToMarkdown() will return a blank string if
                    // there is no HTML to convert. If that is the case,
                    // we will switch to the equivalent Text mode:
                    if (clipboardContents === "") {
                        if (mode === Mode.Markdown) {
                            mode = Mode.Text;
                        }
                        if (mode === Mode.MarkdownBlockquote) {
                            mode = Mode.TextBlockquote;
                        }
                    }
                }
                if (mode === Mode.Text ||
                    mode === Mode.TextBlockquote ||
                    mode === Mode.CodeBlock ||
                    mode === Mode.CodeBlockBlockquote) {
                    clipboardContents = evt.clipboardData.getData("text");
                }
                const leadingWhitespaceMatch = editor
                    .getLine(editor.getCursor().line)
                    .match(new RegExp(`^(\\s*)`));
                const leadingWhitespace = leadingWhitespaceMatch !== null ? leadingWhitespaceMatch[1] : "";
                let input = clipboardContents.split("\n").map((line, i) => {
                    if (i === 0) {
                        return line;
                    }
                    return leadingWhitespace + line;
                });
                if (mode === Mode.Text || mode === Mode.Markdown) {
                    output = input.join("\n");
                }
                if (mode === Mode.CodeBlock) {
                    output = `\`\`\`\n${leadingWhitespace}${input.join("\n")}\n${leadingWhitespace}\`\`\``;
                }
                if (mode === Mode.CodeBlockBlockquote) {
                    input = ["```", leadingWhitespace + input, leadingWhitespace + "```"];
                }
                if (mode === Mode.TextBlockquote ||
                    mode === Mode.MarkdownBlockquote ||
                    mode === Mode.CodeBlockBlockquote) {
                    const toggledText = yield toggleQuote(
                    // We will remove leadingWhitespace from line 0 at the end.
                    // It's just here to calculate overall leading whitespace.
                    [leadingWhitespace + input[0], ...input.slice(1)], this.settings.blockquotePrefix);
                    toggledText.lines[0] = toggledText.lines[0].replace(new RegExp(`^${leadingWhitespace}`), "");
                    output = toggledText.lines.join("\n");
                }
                const transaction = {
                    replaceSelection: output,
                };
                editor.transaction(transaction);
            }));
            Object.values(Mode).forEach((value) => {
                this.addCommand({
                    id: `paste-mode-${value}`,
                    name: `Set Paste Mode to ${value}`,
                    callback: () => changePasteMode(value),
                });
            });
            Object.values(Mode).forEach((value) => {
                this.addCommand({
                    id: `cycle-paste-mode`,
                    name: `Cycle Paste Mode`,
                    callback: () => __awaiter(this, void 0, void 0, function* () {
                        const nextMode = () => {
                            const currentMode = this.settings.mode;
                            const modeValues = Object.values(Mode);
                            let newMode;
                            modeValues.forEach((value, index) => {
                                if (value === currentMode) {
                                    if (index === modeValues.length - 1) {
                                        newMode = modeValues[0];
                                        return newMode;
                                    }
                                    newMode = modeValues[index + 1];
                                    return newMode;
                                }
                            });
                            return newMode;
                        };
                        const newPasteMode = nextMode();
                        yield changePasteMode(newPasteMode);
                        new obsidian.Notice(`Paste mode changed to ${newPasteMode}`);
                    }),
                });
            });
            this.addCommand({
                id: "toggle-blockquote-at-current-indentation",
                name: "Toggle blockquote at current indentation",
                checkCallback: (checking) => {
                    let view = this.app.workspace.getActiveViewOfType(obsidian.MarkdownView);
                    if (view) {
                        if (!checking && view instanceof obsidian.MarkdownView) {
                            toggleQuoteInEditor(view, this.settings.blockquotePrefix);
                        }
                        return true;
                    }
                    return false;
                },
            });
            this.addCommand({
                id: "set-paste-mode",
                name: "Set paste mode",
                callback: () => {
                    const newMode = new PasteModeModal({
                        app,
                        onChooseItem,
                        currentValue: this.settings.mode,
                    });
                    newMode.open();
                },
            });
            this.statusBar = this.addStatusBarItem();
            this.statusBar.setText(`Paste Mode: ${this.settings.mode}`);
            const onChooseItem = (item) => __awaiter(this, void 0, void 0, function* () {
                const selection = Object.values(Mode)[item];
                yield changePasteMode(selection);
            });
            const app = this.app;
            this.statusBar.onClickEvent(() => {
                const newMode = new PasteModeModal({
                    app,
                    onChooseItem,
                    currentValue: this.settings.mode,
                });
                newMode.open();
            });
        });
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
            if (!Object.values(Mode).includes(this.settings.mode)) {
                this.settings.mode = Object.values(Mode)[0];
                this.saveSettings();
            }
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}
class SettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        containerEl.createEl("h2", { text: "Paste to Current Indentation" });
        new obsidian.Setting(containerEl)
            .setName("Paste Mode")
            .setDesc("Mode that the paste command will invoke.")
            .addDropdown((dropdown) => dropdown
            .addOption(Mode.Text, "Plain Text")
            .addOption(Mode.TextBlockquote, "Plain Text (Blockquote)")
            .addOption(Mode.Markdown, "Markdown")
            .addOption(Mode.MarkdownBlockquote, "Markdown (Blockquote)")
            .addOption(Mode.Passthrough, "Passthrough")
            .setValue(this.plugin.settings.mode || DEFAULT_SETTINGS.mode)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.mode =
                value || DEFAULT_SETTINGS.mode;
            yield this.plugin.saveSettings();
            this.plugin.statusBar.setText(`Paste Mode: ${this.plugin.settings.mode}`);
        })));
        new obsidian.Setting(containerEl)
            .setName("Blockquote Prefix")
            .setDesc("Markdown syntax to signify that a line is part of a blockquote.")
            .addText((text) => text
            .setPlaceholder(">•")
            .setValue(this.plugin.settings.blockquotePrefix ===
            DEFAULT_SETTINGS.blockquotePrefix
            ? ""
            : this.plugin.settings.blockquotePrefix)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.blockquotePrefix =
                value !== "" ? value : DEFAULT_SETTINGS.blockquotePrefix;
            yield this.plugin.saveSettings();
        })));
    }
}

module.exports = PastetoIndentationPlugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsInNyYy90b2dnbGUtcXVvdGUudHMiLCJtYWluLnRzIl0sInNvdXJjZXNDb250ZW50IjpudWxsLCJuYW1lcyI6WyJGdXp6eVN1Z2dlc3RNb2RhbCIsIlBsdWdpbiIsImh0bWxUb01hcmtkb3duIiwiTm90aWNlIiwiTWFya2Rvd25WaWV3IiwiUGx1Z2luU2V0dGluZ1RhYiIsIlNldHRpbmciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1REE7QUFDTyxTQUFTLFNBQVMsQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUU7QUFDN0QsSUFBSSxTQUFTLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxPQUFPLEtBQUssWUFBWSxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLFVBQVUsT0FBTyxFQUFFLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7QUFDaEgsSUFBSSxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sRUFBRSxNQUFNLEVBQUU7QUFDL0QsUUFBUSxTQUFTLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO0FBQ25HLFFBQVEsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMs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
