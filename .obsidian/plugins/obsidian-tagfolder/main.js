/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => TagFolderPlugin
});
var import_obsidian = __toModule(require("obsidian"));

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  node.style.setProperty(key, value, important ? "important" : "");
}
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var flushing = false;
var seen_callbacks = new Set();
function flush() {
  if (flushing)
    return;
  flushing = true;
  do {
    for (let i = 0; i < dirty_components.length; i += 1) {
      const component = dirty_components[i];
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  flushing = false;
  seen_callbacks.clear();
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance3, create_fragment3, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment3 ? create_fragment3($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// store.ts
var treeRoot = writable();
var currentFile = writable("");
var maxDepth = writable(0);
var filterString = writable("");

// types.ts
var SUBTREE_MARK = "\u2192 ";
var SUBTREE_MARK_REGEX = /\/→ /g;

// TreeItemComponent.svelte
function add_css(target) {
  append_styles(target, "svelte-1yv0nhj", ".lsl-f.svelte-1yv0nhj{flex-direction:row;display:flex;flex-grow:1}.tagfolder-titletagname.svelte-1yv0nhj{flex-grow:1}.tagfolder-quantity.svelte-1yv0nhj{width:3em;text-align:right}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function create_if_block_3(ctx) {
  let div1;
  let div0;
  let t_value = ctx[0].displayName + "";
  let t;
  let div1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = text(t_value);
      attr(div0, "class", "nav-folder-title-content");
      attr(div1, "class", div1_class_value = "nav-folder-title " + (ctx[5] ? "is-active" : ""));
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t);
      if (!mounted) {
        dispose = [
          listen(div1, "click", ctx[15]),
          listen(div1, "contextmenu", ctx[16])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].displayName + ""))
        set_data(t, t_value);
      if (dirty & 32 && div1_class_value !== (div1_class_value = "nav-folder-title " + (ctx2[5] ? "is-active" : ""))) {
        attr(div1, "class", div1_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let div4;
  let div0;
  let t0;
  let div3;
  let div1;
  let t1_value = ctx[0].tag + "";
  let t1;
  let t2;
  let div2;
  let t3_value = countUnique(ctx[0]) + "";
  let t3;
  let div4_class_value;
  let t4;
  let t5;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[0].children && !ctx[4] && create_if_block_2(ctx);
  let if_block1 = ctx[0].descendants && !ctx[4] && create_if_block_1(ctx);
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      div0.innerHTML = `<svg viewBox="0 0 100 100" class="right-triangle" width="8" height="8"><path fill="currentColor" stroke="currentColor" d="M94.9,20.8c-1.4-2.5-4.1-4.1-7.1-4.1H12.2c-3,0-5.7,1.6-7.1,4.1c-1.3,2.4-1.2,5.2,0.2,7.6L43.1,88c1.5,2.3,4,3.7,6.9,3.7 s5.4-1.4,6.9-3.7l37.8-59.6C96.1,26,96.2,23.2,94.9,20.8L94.9,20.8z"></path></svg>`;
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      t3 = text(t3_value);
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(div0, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div1, "class", "tagfolder-titletagname svelte-1yv0nhj");
      attr(div2, "class", "tagfolder-quantity svelte-1yv0nhj");
      attr(div3, "class", "nav-folder-title-content lsl-f svelte-1yv0nhj");
      attr(div4, "class", div4_class_value = "nav-folder-title " + (ctx[0].children && ctx[4] && ctx[5] ? "is-active" : ""));
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      append(div1, t1);
      append(div3, t2);
      append(div3, div2);
      append(div2, t3);
      insert(target, t4, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div4, "click", ctx[13]),
          listen(div4, "contextmenu", ctx[14])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0].tag + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 1) && t3_value !== (t3_value = countUnique(ctx2[0]) + ""))
        set_data(t3, t3_value);
      if (!current || dirty & 49 && div4_class_value !== (div4_class_value = "nav-folder-title " + (ctx2[0].children && ctx2[4] && ctx2[5] ? "is-active" : ""))) {
        attr(div4, "class", div4_class_value);
      }
      if (ctx2[0].children && !ctx2[4]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 17) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t5.parentNode, t5);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[0].descendants && !ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 17) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (detaching)
        detach(t4);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t5);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2(ctx) {
  let div;
  let current;
  let each_value_1 = ctx[0].children.filter(func);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 143) {
        each_value_1 = ctx2[0].children.filter(func);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[17],
      openfile: ctx[1],
      expandFolder: ctx[2],
      showMenu: ctx[3],
      path: ctx[7]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty & 1)
        treeitemcomponent_changes.entry = ctx2[17];
      if (dirty & 2)
        treeitemcomponent_changes.openfile = ctx2[1];
      if (dirty & 4)
        treeitemcomponent_changes.expandFolder = ctx2[2];
      if (dirty & 8)
        treeitemcomponent_changes.showMenu = ctx2[3];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  let current;
  let each_value = ctx[0].descendants;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 143) {
        each_value = ctx2[0].descendants;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[17],
      openfile: ctx[1],
      expandFolder: ctx[2],
      showMenu: ctx[3],
      path: ctx[7]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty & 1)
        treeitemcomponent_changes.entry = ctx2[17];
      if (dirty & 2)
        treeitemcomponent_changes.openfile = ctx2[1];
      if (dirty & 4)
        treeitemcomponent_changes.expandFolder = ctx2[2];
      if (dirty & 8)
        treeitemcomponent_changes.showMenu = ctx2[3];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_fragment(ctx) {
  let div;
  let show_if;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block, create_if_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (show_if == null || dirty & 65)
      show_if = !!("tag" in ctx2[0] && (ctx2[8] <= ctx2[6] || ctx2[0].tag.startsWith(SUBTREE_MARK)));
    if (show_if)
      return 0;
    if ("path" in ctx2[0])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", div_class_value = "nav-folder " + (ctx[4] ? "is-collapsed" : ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
      if (!current || dirty & 16 && div_class_value !== (div_class_value = "nav-folder " + (ctx2[4] ? "is-collapsed" : ""))) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function getFilenames(entry) {
  if (entry.descendants == null) {
    return [];
  } else {
    const filenames = entry.descendants.map((e) => e.path);
    return Array.from(new Set([...filenames]));
  }
}
function countUnique(entry) {
  return getFilenames(entry).length;
}
var func = (e) => "tag" in e;
function instance($$self, $$props, $$invalidate) {
  let { entry } = $$props;
  let { openfile } = $$props;
  let { expandFolder } = $$props;
  let { showMenu } = $$props;
  let { path } = $$props;
  let collapsed = true;
  let isSelected = false;
  const currentPath = path + ("tag" in entry ? entry.tag + "/" : "");
  const currentDepth = path.replace(SUBTREE_MARK_REGEX, "###").split("/").length;
  let _maxDepth = 0;
  function toggleFolder(entry2) {
    if ("tag" in entry2) {
      expandFolder(entry2, collapsed);
      $$invalidate(4, collapsed = !collapsed);
    }
  }
  function openfileLocal(entry2) {
    if ("path" in entry2)
      openfile(entry2.path);
  }
  function handleContextMenu(e, path2, entry2) {
    showMenu(e, path2, entry2);
  }
  currentFile.subscribe((path2) => {
    $$invalidate(5, isSelected = false);
    if ("tags" in entry && entry.path == path2) {
      $$invalidate(5, isSelected = true);
    }
    if ("tag" in entry && getFilenames(entry).contains(path2)) {
      $$invalidate(5, isSelected = true);
    }
  });
  maxDepth.subscribe((depth) => {
    $$invalidate(6, _maxDepth = depth);
    if (depth == 0) {
      $$invalidate(6, _maxDepth = currentDepth + 1);
    }
  });
  const click_handler = () => toggleFolder(entry);
  const contextmenu_handler = (e) => handleContextMenu(e, currentPath, entry);
  const click_handler_1 = () => openfileLocal(entry);
  const contextmenu_handler_1 = (e) => handleContextMenu(e, currentPath, entry);
  $$self.$$set = ($$props2) => {
    if ("entry" in $$props2)
      $$invalidate(0, entry = $$props2.entry);
    if ("openfile" in $$props2)
      $$invalidate(1, openfile = $$props2.openfile);
    if ("expandFolder" in $$props2)
      $$invalidate(2, expandFolder = $$props2.expandFolder);
    if ("showMenu" in $$props2)
      $$invalidate(3, showMenu = $$props2.showMenu);
    if ("path" in $$props2)
      $$invalidate(12, path = $$props2.path);
  };
  return [
    entry,
    openfile,
    expandFolder,
    showMenu,
    collapsed,
    isSelected,
    _maxDepth,
    currentPath,
    currentDepth,
    toggleFolder,
    openfileLocal,
    handleContextMenu,
    path,
    click_handler,
    contextmenu_handler,
    click_handler_1,
    contextmenu_handler_1
  ];
}
var TreeItemComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      entry: 0,
      openfile: 1,
      expandFolder: 2,
      showMenu: 3,
      path: 12
    }, add_css);
  }
};
var TreeItemComponent_default = TreeItemComponent;

// TagFolderViewComponent.svelte
function add_css2(target) {
  append_styles(target, "svelte-1lyxrts", ".nav-folder.svelte-1lyxrts{padding-bottom:64px}.nav-files-container.svelte-1lyxrts{height:100%}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div1;
  let input;
  let t;
  let div0;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Type to start search...");
      attr(div0, "class", "search-input-clear-button");
      attr(div0, "aria-label", "Clear search");
      set_style(div0, "display", "none");
      attr(div1, "class", "search-input-container");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input);
      set_input_value(input, ctx[8]);
      append(div1, t);
      append(div1, div0);
      if (!mounted) {
        dispose = listen(input, "input", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 256 && input.value !== ctx2[8]) {
        set_input_value(input, ctx2[8]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block2(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent_default({
    props: {
      entry: ctx[13],
      openfile: ctx[1],
      expandFolder: ctx[2],
      showMenu: ctx[4],
      path: "/"
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty & 1)
        treeitemcomponent_changes.entry = ctx2[13];
      if (dirty & 2)
        treeitemcomponent_changes.openfile = ctx2[1];
      if (dirty & 4)
        treeitemcomponent_changes.expandFolder = ctx2[2];
      if (dirty & 16)
        treeitemcomponent_changes.showMenu = ctx2[4];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let div5;
  let div4;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t2;
  let div3;
  let t3;
  let div11;
  let t4;
  let div10;
  let div8;
  let div6;
  let t5;
  let div7;
  let t6;
  let t7;
  let t8;
  let div9;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[9] && create_if_block2(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      div0.innerHTML = `<svg viewBox="0 0 100 100" class="document" width="20" height="20"><path fill="currentColor" stroke="currentColor" d="M14,4v92h72V29.2l-0.6-0.6l-24-24L60.8,4L14,4z M18,8h40v24h24v60H18L18,8z M62,10.9L79.1,28H62V10.9z"></path></svg>`;
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<svg viewBox="0 0 100 100" class="up-and-down-arrows" width="20" height="20"><path fill="currentColor" stroke="currentColor" d="M25.8,5.9c-0.1,0-0.2,0-0.3,0.1c-0.1,0-0.1,0-0.2,0.1c-0.1,0-0.1,0-0.2,0.1c-0.1,0.1-0.3,0.2-0.4,0.3 c-0.1,0.1-0.2,0.1-0.3,0.2c-0.1,0.1-0.2,0.2-0.3,0.3L8.6,22.6c-0.8,0.8-0.8,2.1,0,2.9c0.8,0.8,2.1,0.8,2.9,0L24,12.9V76 c0,0.7,0.4,1.4,1,1.8c0.6,0.4,1.4,0.4,2,0c0.6-0.4,1-1,1-1.8V12.9l12.6,12.6c0.8,0.8,2.1,0.8,2.9,0c0.8-0.8,0.8-2.1,0-2.9 L27.7,6.9c-0.1-0.2-0.3-0.4-0.6-0.6c-0.2-0.2-0.5-0.3-0.8-0.3C26.2,6,26,5.9,25.8,5.9L25.8,5.9z M74,6c-1.1,0-2,0.9-2,2s0.9,2,2,2 s2-0.9,2-2S75.1,6,74,6z M74,14c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S75.1,14,74,14z M73.8,21.9c-0.1,0-0.2,0-0.3,0.1 c-0.9,0.2-1.6,1-1.6,2v63.1L59.4,74.6c-0.5-0.5-1.2-0.7-1.9-0.6c-0.8,0.1-1.4,0.7-1.6,1.4c-0.2,0.7,0,1.5,0.6,2l15.8,15.7 c0,0.1,0.1,0.1,0.1,0.2l0.1,0.1c0,0,0.1,0.1,0.1,0.1c0,0,0,0,0.1,0c0.1,0.1,0.3,0.2,0.4,0.3c0,0,0,0,0.1,0c0,0,0.1,0,0.1,0.1 c0,0,0,0,0.1,0c0.1,0,0.1,0,0.2,0.1c0.2,0,0.4,0,0.6,0c0,0,0.1,0,0.1,0c0.2,0,0.3-0.1,0.5-0.2c0.3-0.1,0.5-0.3,0.7-0.6l15.9-15.8 c0.8-0.8,0.8-2.1,0-2.9c-0.8-0.8-2.1-0.8-2.9,0L76,87.1V24c0-0.6-0.2-1.1-0.6-1.5C75,22.1,74.4,21.9,73.8,21.9L73.8,21.9z M26,82 c-1.1,0-2,0.9-2,2c0,1.1,0.9,2,2,2c1.1,0,2-0.9,2-2C28,82.9,27.1,82,26,82z M26,90c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2 C28,90.9,27.1,90,26,90z"></path></svg>`;
      t1 = space();
      div2 = element("div");
      div2.innerHTML = `<svg viewBox="0 0 100 100" class="stacked-levels" width="20" height="20"><path fill="currentColor" stroke="currentColor" d="M12,4c-1.1,0-2,0.9-2,2v20c0,1.1,0.9,2,2,2h14v21.7c0,0.2,0,0.4,0,0.7V84c0,1.1,0.9,2,2,2h26v8c0,1.1,0.9,2,2,2h32 c1.1,0,2-0.9,2-2V74c0-1.1-0.9-2-2-2H56c-1.1,0-2,0.9-2,2v8H30V52h24v8c0,1.1,0.9,2,2,2h32c1.1,0,2-0.9,2-2V40c0-1.1-0.9-2-2-2 H56c-1.1,0-2,0.9-2,2v8H30V28h14c1.1,0,2-0.9,2-2V6c0-1.1-0.9-2-2-2L12,4z M14,8h28v16H28.3c-0.1,0-0.2,0-0.3,0 c-0.1,0-0.2,0-0.3,0H14L14,8z M58,42h28v16H58v-7.7c0-0.2,0-0.4,0-0.7V42z M58,76h28v16H58v-7.7c0-0.2,0-0.4,0-0.7V76z"></path></svg>`;
      t2 = space();
      div3 = element("div");
      div3.innerHTML = `<svg viewBox="0 0 100 100" class="search" width="20" height="20"><path fill="currentColor" stroke="currentColor" stroke-width="2" d="M42,6C23.2,6,8,21.2,8,40s15.2,34,34,34c7.4,0,14.3-2.4,19.9-6.4l26.3,26.3l5.6-5.6l-26-26.1c5.1-6,8.2-13.7,8.2-22.1 C76,21.2,60.8,6,42,6z M42,10c16.6,0,30,13.4,30,30S58.6,70,42,70S12,56.6,12,40S25.4,10,42,10z"></path></svg>`;
      t3 = space();
      div11 = element("div");
      if (if_block)
        if_block.c();
      t4 = space();
      div10 = element("div");
      div8 = element("div");
      div6 = element("div");
      t5 = space();
      div7 = element("div");
      t6 = text("Tags: ");
      t7 = text(ctx[3]);
      t8 = space();
      div9 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "nav-action-button");
      attr(div0, "aria-label", "New note");
      attr(div1, "class", "nav-action-button");
      attr(div1, "aria-label", "Change sort order");
      attr(div2, "class", "nav-action-button");
      attr(div2, "aria-label", "Expand limit");
      attr(div3, "class", "nav-action-button");
      attr(div3, "aria-label", "Search");
      attr(div4, "class", "nav-buttons-container tagfolder-buttons-container");
      attr(div5, "class", "nav-header");
      attr(div6, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div7, "class", "nav-folder-title-content");
      attr(div8, "class", "nav-folder-title");
      attr(div9, "class", "nav-folder-children");
      attr(div10, "class", "nav-folder mod-root svelte-1lyxrts");
      attr(div11, "class", "nav-files-container svelte-1lyxrts");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      append(div4, t0);
      append(div4, div1);
      append(div4, t1);
      append(div4, div2);
      append(div4, t2);
      append(div4, div3);
      insert(target, t3, anchor);
      insert(target, div11, anchor);
      if (if_block)
        if_block.m(div11, null);
      append(div11, t4);
      append(div11, div10);
      append(div10, div8);
      append(div8, div6);
      append(div8, t5);
      append(div8, div7);
      append(div7, t6);
      append(div7, t7);
      append(div10, t8);
      append(div10, div9);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div9, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", function() {
            if (is_function(ctx[7]))
              ctx[7].apply(this, arguments);
          }),
          listen(div1, "click", function() {
            if (is_function(ctx[6]))
              ctx[6].apply(this, arguments);
          }),
          listen(div2, "click", function() {
            if (is_function(ctx[5]))
              ctx[5].apply(this, arguments);
          }),
          listen(div3, "click", ctx[10])
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[9]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block2(ctx);
          if_block.c();
          if_block.m(div11, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 8)
        set_data(t7, ctx[3]);
      if (dirty & 23) {
        each_value = ctx[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div9, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div11);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { items = [] } = $$props;
  let { openfile } = $$props;
  let { expandFolder } = $$props;
  let { vaultname = "" } = $$props;
  let { showMenu } = $$props;
  let { showLevelSelect } = $$props;
  let { showOrder } = $$props;
  let { newNote } = $$props;
  let { setSearchString } = $$props;
  treeRoot.subscribe((root) => {
    var _a;
    $$invalidate(0, items = (_a = root === null || root === void 0 ? void 0 : root.children) !== null && _a !== void 0 ? _a : []);
  });
  let search = "";
  let showSearch = false;
  function toggleSearch() {
    $$invalidate(9, showSearch = !showSearch);
    if (!showSearch) {
      $$invalidate(8, search = "");
    }
  }
  function input_input_handler() {
    search = this.value;
    $$invalidate(8, search);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("openfile" in $$props2)
      $$invalidate(1, openfile = $$props2.openfile);
    if ("expandFolder" in $$props2)
      $$invalidate(2, expandFolder = $$props2.expandFolder);
    if ("vaultname" in $$props2)
      $$invalidate(3, vaultname = $$props2.vaultname);
    if ("showMenu" in $$props2)
      $$invalidate(4, showMenu = $$props2.showMenu);
    if ("showLevelSelect" in $$props2)
      $$invalidate(5, showLevelSelect = $$props2.showLevelSelect);
    if ("showOrder" in $$props2)
      $$invalidate(6, showOrder = $$props2.showOrder);
    if ("newNote" in $$props2)
      $$invalidate(7, newNote = $$props2.newNote);
    if ("setSearchString" in $$props2)
      $$invalidate(11, setSearchString = $$props2.setSearchString);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2304) {
      $: {
        if (setSearchString != null) {
          setSearchString(search);
        }
      }
    }
  };
  return [
    items,
    openfile,
    expandFolder,
    vaultname,
    showMenu,
    showLevelSelect,
    showOrder,
    newNote,
    search,
    showSearch,
    toggleSearch,
    setSearchString,
    input_input_handler
  ];
}
var TagFolderViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      items: 0,
      openfile: 1,
      expandFolder: 2,
      vaultname: 3,
      showMenu: 4,
      showLevelSelect: 5,
      showOrder: 6,
      newNote: 7,
      setSearchString: 11
    }, add_css2);
  }
};
var TagFolderViewComponent_default = TagFolderViewComponent;

// main.ts
var DEFAULT_SETTINGS = {
  displayMethod: "NAME",
  alwaysOpen: false,
  ignoreDocTags: "",
  ignoreTags: "",
  hideOnRootTags: "",
  sortType: "DISPNAME_ASC",
  sortTypeTag: "NAME_ASC",
  expandLimit: 0
};
var VIEW_TYPE_TAGFOLDER = "tagfolder-view";
var OrderKeyTag = {
  NAME: "File name",
  ITEMS: "Count of items"
};
var OrderDirection = {
  ASC: "Ascending",
  DESC: "Descending"
};
var OrderKeyItem = {
  DISPNAME: "Displaying name",
  NAME: "File name",
  MTIME: "Modified time",
  FULLPATH: "Fullpath of the file"
};
var TagFolderView = class extends import_obsidian.ItemView {
  getIcon() {
    return "stacked-levels";
  }
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.showMenu = this.showMenu.bind(this);
    this.showOrder = this.showOrder.bind(this);
    this.newNote = this.newNote.bind(this);
    this.showLevelSelect = this.showLevelSelect.bind(this);
  }
  newNote(evt) {
    this.app.commands.executeCommandById("file-explorer:new-file");
  }
  showOrder(evt) {
    const menu = new import_obsidian.Menu(this.app);
    menu.addItem((item) => {
      item.setTitle("Tags").setIcon("hashtag").onClick((evt2) => __async(this, null, function* () {
        const menu2 = new import_obsidian.Menu(this.app);
        for (const key in OrderKeyTag) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(OrderKeyTag[key] + " " + OrderDirection[direction]).onClick(() => __async(this, null, function* () {
                this.plugin.settings.sortTypeTag = newSetting;
                yield this.plugin.saveSettings();
                this.plugin.setRoot(this.plugin.root);
              }));
              if (newSetting == this.plugin.settings.sortTypeTag) {
                item2.setIcon("checkmark");
              }
              menu2.showAtMouseEvent(evt);
              return item2;
            });
          }
        }
      }));
      return item;
    });
    menu.addItem((item) => {
      item.setTitle("Items").setIcon("document").onClick((evt2) => __async(this, null, function* () {
        const menu2 = new import_obsidian.Menu(this.app);
        for (const key in OrderKeyItem) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(OrderKeyItem[key] + " " + OrderDirection[direction]).onClick(() => __async(this, null, function* () {
                this.plugin.settings.sortType = newSetting;
                yield this.plugin.saveSettings();
                this.plugin.setRoot(this.plugin.root);
              }));
              if (newSetting == this.plugin.settings.sortType) {
                item2.setIcon("checkmark");
              }
              menu2.showAtMouseEvent(evt);
              return item2;
            });
          }
        }
      }));
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  showLevelSelect(evt) {
    const menu = new import_obsidian.Menu(this.app);
    const setLevel = (level) => __async(this, null, function* () {
      this.plugin.settings.expandLimit = level;
      yield this.plugin.saveSettings();
      maxDepth.set(level);
      this.plugin.setRoot(this.plugin.root);
    });
    for (const level of [2, 3, 4, 5]) {
      menu.addItem((item) => {
        item.setTitle(`Level ${level - 1}`).onClick(() => {
          setLevel(level);
        });
        if (this.plugin.settings.expandLimit == level)
          item.setIcon("checkmark");
        return item;
      });
    }
    menu.addItem((item) => {
      item.setTitle("No limit").onClick(() => {
        setLevel(0);
      });
      if (this.plugin.settings.expandLimit == 0)
        item.setIcon("checkmark");
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  getViewType() {
    return VIEW_TYPE_TAGFOLDER;
  }
  getDisplayText() {
    return "Tag Folder";
  }
  onOpen() {
    return __async(this, null, function* () {
      this.component = new TagFolderViewComponent_default({
        target: this.contentEl,
        props: {
          openfile: this.plugin.focusFile,
          expandFolder: this.plugin.expandFolder,
          vaultname: this.app.vault.getName(),
          showMenu: this.showMenu,
          showLevelSelect: this.showLevelSelect,
          showOrder: this.showOrder,
          newNote: this.newNote,
          setSearchString: this.plugin.setSearchString
        }
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      this.component.$destroy();
    });
  }
  setTreeRoot(root) {
    treeRoot.set(root);
  }
  showMenu(evt, path, entry) {
    const x = path.replace(SUBTREE_MARK_REGEX, "###");
    const expandedTags = x.split("/").filter((e) => e.trim() != "").map((e) => e.replace(/###/g, "/")).map((e) => "#" + e).join(" ").trim();
    const menu = new import_obsidian.Menu(this.app);
    if (navigator && navigator.clipboard) {
      menu.addItem((item) => item.setTitle("Copy tags").setIcon("hashtag").onClick(() => __async(this, null, function* () {
        yield navigator.clipboard.writeText(expandedTags);
        new import_obsidian.Notice("Copied");
      })));
    }
    menu.showAtMouseEvent(evt);
  }
};
var rippleDirty = (entry) => {
  for (const child of entry.children) {
    if ("tag" in child) {
      if (rippleDirty(child)) {
        entry.descendants = null;
      }
    }
  }
  if (entry.descendants == null)
    return true;
};
var expandDecendants = (entry) => {
  const ret = [];
  for (const v of entry.children) {
    if ("tag" in v) {
      if (v.descendants == null) {
        ret.push(...expandDecendants(v).filter((e) => !ret.contains(e)));
      } else {
        ret.push(...v.descendants.filter((e) => !ret.contains(e)));
      }
    } else {
      if (!ret.contains(v))
        ret.push(v);
    }
  }
  entry.descendants = ret;
  return ret;
};
var expandTree = (node) => {
  const tree = node.children;
  const ancestor = [...node.ancestors, node.tag];
  const tags = Array.from(new Set(node.children.filter((e) => "tags" in e).map((e) => e.tags).map((e) => e.map((ee) => ee.toLocaleString())).flat()));
  for (const tag of tags) {
    if (ancestor.map((e) => e.toLocaleLowerCase()).contains(tag.toLocaleLowerCase()))
      continue;
    const newChildren = node.children.filter((e) => "tags" in e && e.tags.map((e2) => e2.toLocaleLowerCase()).contains(tag.toLocaleLowerCase()));
    if (tree.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tag.toLocaleLowerCase())) {
      continue;
    }
    const newLeaf = {
      tag,
      children: newChildren,
      ancestors: [...ancestor, tag],
      descendants: null
    };
    tree.push(newLeaf);
    splitTag(newLeaf);
  }
};
var splitTag = (entry) => {
  let modified = false;
  entry.children = entry.children.sort((a, b) => {
    if ("tag" in a && "tag" in b) {
      return a.tag.split("/").length - b.tag.split("/").length;
    } else {
      return 0;
    }
  });
  for (const curEntry of entry.children) {
    if ("tag" in curEntry) {
      modified = splitTag(curEntry) || modified;
      if (curEntry.tag.contains("/")) {
        const tempEntry = curEntry;
        entry.children.remove(tempEntry);
        const tagsArray = tempEntry.tag.split("/");
        const tagCar = tagsArray.shift();
        const tagCdr = SUBTREE_MARK + tagsArray.join("/");
        const parent = entry.children.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tagCar.toLocaleLowerCase());
        const tempChildren = tempEntry.children;
        if (!parent) {
          const xchild = {
            tag: tagCdr,
            children: [...tempChildren],
            ancestors: [
              ...tempEntry.ancestors,
              tempEntry.tag,
              tagCdr
            ],
            descendants: null
          };
          const x = {
            tag: tagCar,
            children: [xchild],
            ancestors: [...tempEntry.ancestors, tempEntry.tag],
            descendants: null
          };
          x.children = [xchild];
          entry.children.push(x);
          splitTag(entry);
          modified = true;
        } else {
          const oldIx = parent.children.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tagCdr.toLocaleLowerCase());
          if (oldIx != null) {
            oldIx.children.push(...tempChildren.filter((e) => !oldIx.children.contains(e)));
            splitTag(oldIx);
          } else {
            const x = {
              tag: tagCdr,
              children: [...tempChildren],
              ancestors: [
                ...tempEntry.ancestors,
                tempEntry.tag,
                tagCdr
              ],
              descendants: null
            };
            parent.children.push(x);
            splitTag(parent);
          }
          modified = true;
        }
      }
    }
  }
  if (modified) {
    splitTag(entry);
  }
  return modified;
};
function getCompareMethodTags(settings) {
  const invert = settings.sortTypeTag.contains("_DESC") ? -1 : 1;
  switch (settings.sortTypeTag) {
    case "ITEMS_ASC":
    case "ITEMS_DESC":
      return (a, b) => (a.descendants.length - b.descendants.length) * invert;
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b) => a.tag.localeCompare(b.tag) * invert;
    default:
      console.warn("Compare method (tags) corrupted");
      return (a, b) => a.tag.localeCompare(b.tag) * invert;
  }
}
function getCompareMethodItems(settings) {
  const invert = settings.sortType.contains("_DESC") ? -1 : 1;
  switch (settings.sortType) {
    case "DISPNAME_ASC":
    case "DISPNAME_DESC":
      return (a, b) => a.displayName.localeCompare(b.displayName) * invert;
    case "FULLPATH_ASC":
    case "FULLPATH_DESC":
      return (a, b) => a.path.localeCompare(b.path) * invert;
    case "MTIME_ASC":
    case "MTIME_DESC":
      return (a, b) => (a.mtime - b.mtime) * invert;
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b) => a.filename.localeCompare(b.filename) * invert;
    default:
      console.warn("Compare method (items) corrupted");
      return (a, b) => a.displayName.localeCompare(b.displayName) * invert;
  }
}
var TagFolderPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.expandedFolders = ["root"];
    this.currentOpeningFile = "";
    this.searchString = "";
    this.focusFile = (path) => {
      const targetFile = this.app.vault.getFiles().find((f) => f.path === path);
      if (targetFile) {
        const leaf = this.app.workspace.getLeaf(false);
        leaf.openFile(targetFile);
      }
    };
    this.expandFolder = (entry, expanded) => {
      if ("tag" in entry) {
        const key = [...entry.ancestors, entry.tag].join("/");
        if (expanded) {
          this.expandedFolders = Array.from(new Set([...this.expandedFolders, key]));
          this.expandedFolders = this.expandedFolders.sort((a, b) => a.split("/").length - b.split("/").length);
        } else {
          this.expandedFolders = this.expandedFolders.filter((e) => e != key);
        }
        this.expandLastExpandedFolders(entry);
        this.setRoot(this.root);
      }
    };
    this.fileCaches = [];
  }
  getView() {
    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)) {
      const view = leaf.view;
      if (view instanceof TagFolderView) {
        return view;
      }
    }
    return null;
  }
  setSearchString(search) {
    this.searchString = search;
    this.refreshAllTree(null);
  }
  expandLastExpandedFolders(entry) {
    if ("tag" in entry) {
      const key = [...entry.ancestors, entry.tag].join("/");
      if (this.expandedFolders.contains(key)) {
        expandTree(entry);
        splitTag(entry);
        for (const child of entry.children) {
          this.expandLastExpandedFolders(child);
        }
      }
    }
  }
  getDisplayName(file) {
    if (this.settings.displayMethod == "NAME") {
      return file.basename;
    }
    const path = file.path.split("/");
    path.pop();
    const dpath = path.join("/");
    if (this.settings.displayMethod == "NAME : PATH") {
      return `${file.basename} : ${dpath}`;
    }
    if (this.settings.displayMethod == "PATH/NAME") {
      return `${dpath}/${file.basename}`;
    }
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.sortChildren = this.sortChildren.bind(this);
      this.setSearchString = this.setSearchString.bind(this);
      this.loadFileInfo = (0, import_obsidian.debounce)(this.loadFileInfo.bind(this), 250, true);
      this.registerView(VIEW_TYPE_TAGFOLDER, (leaf) => new TagFolderView(leaf, this));
      this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
        if (this.settings.alwaysOpen) {
          this.activateView();
        }
      }));
      this.addCommand({
        id: "tagfolder-open",
        name: "Show Tag Folder",
        callback: () => {
          this.activateView();
        }
      });
      this.metadataCacheChanged = this.metadataCacheChanged.bind(this);
      this.watchWorkspaceOpen = this.watchWorkspaceOpen.bind(this);
      this.registerEvent(this.app.metadataCache.on("changed", this.metadataCacheChanged));
      this.refreshAllTree = this.refreshAllTree.bind(this);
      this.registerEvent(this.app.vault.on("rename", this.refreshAllTree));
      this.registerEvent(this.app.vault.on("delete", this.refreshAllTree));
      this.registerEvent(this.app.workspace.on("file-open", this.watchWorkspaceOpen));
      this.watchWorkspaceOpen(this.app.workspace.getActiveFile());
      this.addSettingTab(new TagFolderSettingTab(this.app, this));
      maxDepth.set(this.settings.expandLimit);
    });
  }
  watchWorkspaceOpen(file) {
    if (file) {
      this.currentOpeningFile = file.path;
    } else {
      this.currentOpeningFile = "";
    }
    currentFile.set(this.currentOpeningFile);
  }
  metadataCacheChanged(file) {
    this.loadFileInfo(file);
  }
  refreshAllTree(file) {
    this.loadFileInfo();
  }
  sortChildren(a, b) {
    if ("tag" in a && !("tag" in b)) {
      return -1;
    } else if (!("tag" in a) && "tag" in b) {
      return 1;
    } else {
      if ("tag" in a && "tag" in b) {
        return this.compareTags(a, b);
      } else if ("tags" in a && "tags" in b) {
        return this.compareItems(a, b);
      } else {
        return 0;
      }
    }
  }
  sortTree(entry) {
    entry.children = entry.children.sort(this.sortChildren);
    for (const child of entry.children) {
      if ("tag" in child) {
        this.sortTree(child);
      }
    }
    entry.descendants = entry.descendants.sort(this.sortChildren);
  }
  setRoot(root) {
    var _a;
    rippleDirty(root);
    expandDecendants(root);
    this.sortTree(root);
    this.root = root;
    (_a = this.getView()) == null ? void 0 : _a.setTreeRoot(root);
  }
  updateFileCaches(diff) {
    if (this.fileCaches.length == 0 || !diff) {
      const files = this.app.vault.getMarkdownFiles();
      this.fileCaches = files.map((fileEntry) => {
        return {
          file: fileEntry,
          metadata: this.app.metadataCache.getFileCache(fileEntry)
        };
      });
    } else {
      this.fileCaches = this.fileCaches.filter((fileCache) => fileCache.file.path != diff.path);
      this.fileCaches.push({
        file: diff,
        metadata: this.app.metadataCache.getFileCache(diff)
      });
    }
  }
  getItemsList() {
    const items = [];
    const ignoreDocTags = this.settings.ignoreDocTags.replace(/\n| /g, "").split(",");
    const ignoreTags = this.settings.ignoreTags.replace(/\n| /g, "").split(",");
    const searchItems = this.searchString.split("|").map((ee) => ee.split(" ").map((e) => e.trim()));
    for (const fileCache of this.fileCaches) {
      const allTagsDocs = (0, import_obsidian.getAllTags)(fileCache.metadata);
      let allTags = allTagsDocs.map((e) => e.substring(1));
      if (allTags.length == 0) {
        allTags = ["_untagged"];
      }
      if (allTags.some((tag) => ignoreDocTags.contains(tag))) {
        continue;
      }
      const w = searchItems.map((searchItem) => {
        let bx = false;
        for (const search of searchItem) {
          if (search.startsWith("-")) {
            bx = bx || allTags.some((tag) => tag.contains(search.substring(1)));
            if (bx)
              continue;
          } else {
            bx = bx || allTags.every((tag) => !tag.contains(search));
            if (bx)
              continue;
          }
        }
        return bx;
      });
      if (w.every((e) => e))
        continue;
      allTags = allTags.filter((tag) => !ignoreTags.contains(tag));
      items.push({
        tags: allTags,
        path: fileCache.file.path,
        displayName: this.getDisplayName(fileCache.file),
        ancestors: [],
        mtime: fileCache.file.stat.mtime,
        filename: fileCache.file.basename
      });
    }
    return items;
  }
  buildUpTree(items) {
    const root = {
      tag: "root",
      children: [...items],
      ancestors: [],
      descendants: null
    };
    expandTree(root);
    root.children = root.children.filter((e) => "tag" in e);
    splitTag(root);
    this.expandLastExpandedFolders(root);
    return root;
  }
  loadFileInfo(diff) {
    if (this.getView() == null)
      return;
    this.updateFileCaches(diff);
    const items = this.getItemsList();
    const root = this.buildUpTree(items);
    this.setRoot(root);
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER);
  }
  activateView() {
    return __async(this, null, function* () {
      this.loadFileInfo();
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER);
      yield this.app.workspace.getLeftLeaf(false).setViewState({
        type: VIEW_TYPE_TAGFOLDER,
        active: true
      });
      this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)[0]);
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      this.compareItems = getCompareMethodItems(this.settings);
      this.compareTags = getCompareMethodTags(this.settings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      this.compareItems = getCompareMethodItems(this.settings);
      this.compareTags = getCompareMethodTags(this.settings);
    });
  }
};
var TagFolderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  hide() {
    this.plugin.loadFileInfo();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Tag Folder." });
    new import_obsidian.Setting(containerEl).setName("Always Open").setDesc("Open Tag Folder when obsidian has been launched").addToggle((toggle) => toggle.setValue(this.plugin.settings.alwaysOpen).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.alwaysOpen = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Display method").setDesc("Filename display").addDropdown((dropdown) => dropdown.addOptions({
      "PATH/NAME": "PATH/NAME",
      NAME: "NAME",
      "NAME : PATH": "NAME : PATH"
    }).setValue(this.plugin.settings.displayMethod).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.displayMethod = value;
      this.plugin.loadFileInfo(null);
      yield this.plugin.saveSettings();
    })));
    const setOrderMethod = (key, order) => __async(this, null, function* () {
      const oldSetting = this.plugin.settings.sortType.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortType = `${key}_${order}`;
      yield this.plugin.saveSettings();
      this.plugin.setRoot(this.plugin.root);
    });
    const setOrderMethodTag = (key, order) => __async(this, null, function* () {
      const oldSetting = this.plugin.settings.sortTypeTag.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortTypeTag = `${key}_${order}`;
      yield this.plugin.saveSettings();
      this.plugin.setRoot(this.plugin.root);
    });
    new import_obsidian.Setting(containerEl).setName("Order method (Tags)").setDesc("how to order tags").addDropdown((dd) => {
      dd.addOptions(OrderKeyTag).setValue(this.plugin.settings.sortTypeTag.split("_")[0]).onChange((key) => setOrderMethodTag(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortTypeTag.split("_")[1]).onChange((order) => setOrderMethodTag(null, order));
    });
    new import_obsidian.Setting(containerEl).setName("Order method (Items)").setDesc("how to order items").addDropdown((dd) => {
      dd.addOptions(OrderKeyItem).setValue(this.plugin.settings.sortType.split("_")[0]).onChange((key) => setOrderMethod(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortType.split("_")[1]).onChange((order) => setOrderMethod(null, order));
    });
    new import_obsidian.Setting(containerEl).setName("Ignore note Tag").setDesc("If the note has the tag listed below, the note would be treated as there was not.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreDocTags).setPlaceholder("test,test1,test2").onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ignoreDocTags = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Ignore Tag").setDesc("Tags in the list would be treated as there were not.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreTags).setPlaceholder("test,test1,test2").onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ignoreTags = value;
      yield this.plugin.saveSettings();
    })));
  }
};
