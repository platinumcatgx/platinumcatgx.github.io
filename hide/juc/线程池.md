# 线程的声明周期

![image-20210407101511428](线程池.assets\image-20210407101511428.png)

虚拟机中:

- 新建 new--- new
- 就绪 runnable --- start
- 阻塞 blocked --- 无法获得锁
- 等待 wait --- wait
- 计时等待 timed_wait --- sleep [未加锁时, 其他线程会执行]
- 死亡 terminated --- 执行完毕

## 线程池

创建线程的成本时比较高的,  频繁的创建和销毁线程会浪费资源

**步骤**

创建线程池

需要执行任务, 从线程池中获取线程

放回线程池

![image-20210407103421426](线程池.assets\image-20210407103421426.png)

创建无界(int的max值)的线程池:  Excutors.newCacheThreadPool()  : 不建议使用

创建指定上限的线程池

Excutors.newFixedTHreadPool(int size)// 设置的是最大值, 不是初始值

```java
ThreadPoolExecutor tpe= (ThreadPoolExecutor)executorService;
tpe.getPoolSize();//获取线程池中的线程数量
```

任务拒绝策略

![image-20210407141840313](线程池.assets\image-20210407141840313.png)

![image-20210407144458066](线程池.assets\image-20210407144458066.png)

## 同步问题

Java 内存模型规定，**对于多个线程共享的变量，存储在主内存当中**，**每个线程都有自己独立的工作内存，并且线程只能访问自己的工作内存，不可以访问其它线程的工作内存**。**工作内存中保存了主内存中共享变量的副本**，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中，其 JVM 模型大致如下图。

![image-20210407141840313](线程池.assets\lc.png)

多线程操作时, 数据包未同步, 导致部分线程读取到的值不是最新的

### 解决方案

#### synchronized解决

##### synchronized解决

​	1 ，线程获得锁

​	2 ，清空变量副本

​	3 ，拷贝共享变量最新的值到变量副本中

​	4 ，执行代码

​	5 ，将修改后变量副本中的值赋值给共享数据

​	6 ，释放锁

##### **Volatile**

![image-20210407153955687](线程池.assets\image-20210407153955687.png)

synchroized方式效率过低, 一般不会优先考虑



### 原子性

i++分为三部

int temp = i

temp = temp+1;

i  = temp;

在执行中间执行时, 随时可能被其他线程抢走CPU执行权,  

原子性:  不可分割

### 原子类

原子包: java.util.concurrent.atomic

并发包: java.util.concurrent

AtomicInteger : 原子型Integer

![image-20210407161043954](线程池.assets\image-20210407161043954.png)

### CAS 算法

count在内存中分为三部

![image-20210407163337163](线程池.assets\image-20210407163337163.png)

![image-20210407163424247](线程池.assets\image-20210407163424247.png)

**源码解析**

```java
class test {
    public final int incrementAndGet() {
        return U.getAndAddInt(this, VALUE, 1) + 1;
    }

    public final int getAndAddInt(Object o, long offset, int delta) {
        int v;
        do {
            v = getIntVolatile(o, offset);
        } while (!weakCompareAndSetInt(o, offset, v, v + delta));
        return v;
    }
}
```

![image-20210407164957025](线程池.assets\image-20210407164957025.png)

### 悲观锁 - 乐观锁

相同点

![image-20210407165742066](线程池.assets\image-20210407165742066.png)

不同点

![image-20210407165817833](线程池.assets\image-20210407165817833.png)

## 集合与多线程

HashMap

线程不安全

HashTable

线程安全, 但是效率低下

采用了悲观锁的形式保证线程的安全性

只要有线程访问, 就会将整张表锁起来

![image-20210407182516666](线程池.assets\image-20210407182516666.png)

在JDK7和JDK8中, 底层原理不一样

JDK7

1. 默认创建长度16 加载因子0.75的大数组, 这个大数组无法扩容
2. 还会创建一个长度为2的小数组, 把地址值赋给0索引
3. 第一次会根据键的哈希值来计算出在大数组中应存入的位置, 如果为null, 则按照模板创建小数组,  二次哈希, 计算在小数组中的位置, 存入

![image-20210407184027565](线程池.assets\image-20210407184027565.png)

![image-20210407184045239](线程池.assets\image-20210407184045239.png)

JDK8将挂哈希桶改成了挂红黑树,  由悲观锁改为乐观锁

![image-20210407185249803](线程池.assets\image-20210407185249803.png)

#### 并发工具类

![image-20210407191000459](线程池.assets\image-20210407191000459.png)

使用场景

让某一小城等待其他线程执行完毕之后再执行

![image-20210407192408020](线程池.assets\image-20210407192408020.png)

