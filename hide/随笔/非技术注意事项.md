# 非技术注意事项

# From

[https://bugstack.cn/md/develop/standard/2020-09-14-一次代码评审，差点过不了试用期！.html](https://bugstack.cn/md/develop/standard/2020-09-14-%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1%EF%BC%8C%E5%B7%AE%E7%82%B9%E8%BF%87%E4%B8%8D%E4%BA%86%E8%AF%95%E7%94%A8%E6%9C%9F%EF%BC%81.html)


# 摘要

主要包含以下几个方面:

日志, 代码格式, IDE提示, 测试, 分支,  需求,  异常, 代码,  SQL

## 日志

日志是必须要打的，而且要打好日志。线上出现Bug，好的日志能够快速定位问题。

**示例代码** 

```java
// 修改前
public Result execRule(RuleReq req) {
    try {
        logger.info("执行服务规则 req：{}", JSON.toJSONString(req));
        // 业务流程
        return Result.buildSuccess();
    } catch (Exception e) {
        logger.error("执行服务规则失败", e);
        return Result.buildError(e);
    }
}

```


代码的问题在异常部分, 如果代码除了异常, 那么日志中不会包含入参, 很难判断出问题具体原因

> 另外如果你的系统监控服务，没有类似方法跟踪ID的功能，最好还需要在日志中把本次调用具有标识性的id，作为查询条件打到日志中。


修改后:

```java
public Result execRule(RuleReq req) {
    try {
        logger.info("执行服务规则{}开始 req：{}", req.getrId(), JSON.toJSONString(req));
        // 业务流程
        logger.info("执行服务规则{}完成 res：{}", req.getrId(), "业务流程，必要的结果信息");
        return Result.buildSuccess();
    } catch (Exception e) {
        logger.error("执行服务规则{}失败 req：{}", req.getrId(), JSON.toJSONString(req), e);
        return Result.buildError(e);
    }
}
```


## IDE提示

IDEA对代码的隐藏问题会给出提示,  例如单词错误,  Slf4J日志的括号数与实参数不对应, 都会给出⚠警告


## 代码格式

良好的代码格式对代码的阅读后很好的帮助, 例如代码符号之间的空格,  长代码的换行


## 单元测试

写好单元测试, 保证自己的功能都是无误的, 才能提交给测试.

经过测试的代码, 才能放下的交给下一个流程, 否则只会来回折腾, 耗时耗力

- 引用

&ensp;&ensp;&ensp;&ensp;[https://www.jianshu.com/p/53607feca6aa](https://www.jianshu.com/p/53607feca6aa)
&ensp;&ensp;&ensp;&ensp;软件的正确性包含以下几个点

&ensp;&ensp;&ensp;&ensp;- **流程符合预期** ，即按照设计的步骤运行，并在关键的步骤执行正确的功能，包含正确的参数；

&ensp;&ensp;&ensp;&ensp;- **执行效果** 符合预期，即通过功能执行后，能够产生符合设计的结果，这种结果可以是直接的，比如方法的返回值；也可以是间接的，比如方法改变了实例中可被观察到的部分；

&ensp;&ensp;&ensp;&ensp;- **异常保护符合预期** ，功能执行过程会遭遇超越设计边界的场景，保护自身不因“越界”而失效；

&ensp;&ensp;&ensp;&ensp;- **质量属性符合预期** ，某些功能具有质量属性，如响应时间等。

&ensp;&ensp;&ensp;&ensp;单元测试重点在于验证软件正确，而覆盖率重点在于描述测试的充分程度，两者不会等同起来

&ensp;&ensp;&ensp;&ensp;测试代码最重要的东西——对预期的判断

&ensp;&ensp;&ensp;&ensp;覆盖率的目的是在有效单元测试的基础上统计测试代码测试被测对象的充分程度

&ensp;&ensp;&ensp;&ensp;在保证单元测试实现其目的的情况下，上述认识才真正变得有意义


## 分支规范

原文描述, 项目分支一般包括以下三个分支:  master分支, 也就是生产环境代码, test分支, 测试分支, 需求分支,  开发分支,  同一个需求下, 会在同一个分支下开发

但是如果不遵守公司的代码分支规范, 则代码是很容易出问题的, 会严重影响上线


## 夹带需求

例如在修改 BugA 的代码, 顺带优化了 模块B 的代码$^1$, 但是未通知测试

$^1$:  也可能是其他问题, 例如修复某个Bug, 或者添加入了某个产品提出的需求, 认为问题很小,  无需通知测试

这会导致代码跳过测试流程,  代码的正确性不能的到良好的保障, 代码是有隐患的


## 异常流程

> 擦屁屁的纸，80%的面积都是保护手的！


> 我们编程很多时候都是在处理异常流程，正常流程往往并不难，难的是分析出这段开发的代码有多少异常流程有没有处理


列举问题

1. 支付成功MQ消息发送失败，需要worker补偿

2. PRC接口调用失败，网络超时，实际成功

3. 接口幂等性，多次调用结果一致性

4. ...

> 这些都是异常流程，尤其在一些交易提现环节，会出现各种异常，那么不可能把这些异常都反馈用户展示到界面。而是要有一些非常友好的提示，并且在服务端的流程里，有一定的补偿机制，来保证最终的调用成功，或者逆反



## 代码成坨

> CRUD往往可能是因为你的设计，换个人写也许不同


在不考虑代码的拓展性的情况下, 用大量的if else 也是能完成问题的;

通过设计模式, 能够让自己的代码变得更好, 推荐下原文作者推荐的《重学Java设计模式》


## SQL性能

SQL的编写需要考虑性能, 应尽量避免全表扫描, 防止数据量较大时, SQL执行速度得不到保障


## 陪伴编程

不是指结伴变成, 也不是共同合作, 这是一个研发人员缺乏 独立编程习惯或能力 的表现

> 及早断奶，学会自己攻克，快速成长



## 总结

> 这些问题点但拿出哪一个看，都不大。但运行在代码中，确都有可能发生致命或者麻烦的事情


> 只要你不能正确的落地和运用这些技术，说的再多都是空谈


